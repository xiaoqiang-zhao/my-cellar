<!DOCTYPE html>
<html>
<head lang="zh-cn">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Python 学习笔记 - 小强赵的个人站点</title>
    <script>
        // 用户通过搜索引擎到文章详情页时，跳到首页并进行哈希路由
        var href = window.location.href.replace(/[^:|\/]\//,function (matchStr){
            return matchStr + 'index.html#!';
        });
        window.location.href = href.replace('/main.html', '');
    </script>
</head>
<body>
<header>
    <h1> 小强赵的个人站点 </h1>
    <h2> 精进自己，服务他人 </h2>
</header>
<div>
    <h1 id="header-1">Python 学习笔记</h1>
<blockquote>
<p>多学个东西。</p>
</blockquote>
<h2 id="header-1-1">概述</h2>
<p>Python ，诞生于 1989，是一种跨平台的计算机程序设计语言，语言类型为”解释型脚本“，既支持面向过程的编程也支持面向对象的编程。</p>
<p>Python 在执行时，首先会将 .py 文件中的源代码编译成 Python 的 byte code（字节码），然后再由 Python Virtual Machine（Python虚拟机）来执行这些编译好的 byte code。</p>
<p>Python 本身被设计为可扩充的。并非所有的特性和功能都集成到语言核心。Python 提供了丰富的 API 和工具，以便程序员能够轻松地使用 C 语言、C++、Cython 来编写扩充模块。Python 编译器本身也可以被集成到其它需要脚本语言的程序内。因此，很多人还把Python作为一种“胶水语言”（glue language）使用。</p>
<p>主要用途:</p>
<ul>
<li>Web 开发</li>
<li>科学计算和统计</li>
<li>人工智能</li>
<li>桌面界面开发</li>
<li>网络爬虫</li>
</ul>
<p>缺点: </p>
<ol>
<li>因为是解释型语言，相比C，运行速度慢;</li>
<li>代码不能加密。</li>
</ol>
<h2 id="header-1-2">快读入门</h2>
<p>当前稳定版: 3.8，Mac 预装了 Python，执行 <code>python -V</code>，查看版本。如果版本太低去官网下载最新稳定版: <a href="https://www.python.org/downloads/，直接就是" target="_blank">https://www.python.org/downloads/，直接就是</a> <a href="https://www.python.org/ftp/python/3.8.3/python-3.8.3-macosx10.9.pkg" target="_blank">pkg</a> 文件，傻瓜式安装。</p>
<p>安装完成后会弹出安装目录，点击 IDLE 可以直接进入 Python 命令行窗口，输入 <code>print(&quot;Hello world!&quot;)</code> 回车，第一行 Python 命令就执行了。用 <code>exit()</code> 退出命令行。</p>
<p>你还可以把代码写进文件:</p>
<pre><code class="lang-python"># 01-hello-world.py
print(&quot;Hello world!&quot;)
</code></pre>
<p>在命令行执行 <code>python ./01-hello-world.py</code> 同样可以输出结果。</p>
<p>脚本语言没有复杂的数据类型定义，Python 更是采用了 4 个空格的缩进作为逻辑块分割，我们多写几行代码:</p>
<pre><code class="lang-python"># 02-if-else.py
a = 1
if a &gt; 0:
    print(&quot;a 为整数&quot;)
else:
    print(&quot;a 不为整数&quot;)
</code></pre>
<p>IDE 可以用我熟悉的 VS Code，可以断点调试。(pycharm 也是不错的选择)</p>
<h2 id="header-1-3">VS Code</h2>
<p>给 VS Code 装个插件就可以直接运行 .py 文件了。</p>
<h2 id="header-1-4">解析器</h2>
<p>整个 Python 语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写 Python 解释器来执行 Python 代码（当然难度很大）。事实上，确实存在多种 Python 解释器。</p>
<p>我们用官方版本的解释器 CPython。这个解释器是用 C 语言开发的，所以叫 CPython。</p>
<h2 id="header-1-5">Python 基础</h2>
<p>支持整数、浮点数、字符串(包括多行字符串)、布尔值、空值(None)、常量.</p>
<pre><code class="lang-python"># 赋值后直接改变数据类型
a = 123
print(a)
a = &#39;ABC&#39;
print(a)

# 不能改变数据类型
int a = 123;
a = &quot;ABC&quot;; # 错误：不能把字符串赋给整型变量

# 03-data-type.py
s = &#39;&#39;&#39;
line 1
line 2
line 3
&#39;&#39;&#39;
print(s)
</code></pre>
<p>数据集 list</p>
<pre><code class="lang-python">classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
len(classmates)
# 输出 3

classmates[0]
# &#39;Michael&#39;

classmates[-1]
# &#39;Tracy&#39;

classmates.append(&#39;Adam&#39;)
# [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;]

classmates.insert(1, &#39;Jack&#39;)
# [&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;]
</code></pre>
<p>要删除 list 末尾的元素，用 <code>pop()</code> 方法。</p>
<p>要删除指定位置的元素，用 <code>pop(i)</code> 方法。</p>
<p>list 中可放置数据类型不同的元素。</p>
<p>另一种有序列表叫元组：tuple。tuple 和 list 非常类似，但是 tuple 一旦初始化就不能修改。</p>
<pre><code class="lang-python">classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)

# 三种定义方式
a = ()
d = (3,)
e = (4,5,6)

# 间接修改
t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])
t[2][0] = &#39;X&#39;
</code></pre>
<p>条件判断</p>
<pre><code class="lang-python">age = 20
if age &gt;= 6:
    print(&#39;teenager&#39;)
elif age &gt;= 18:
    print(&#39;adult&#39;)
else:
    print(&#39;kid&#39;)
</code></pre>
<p>for in 循环</p>
<pre><code class="lang-python">names = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
for name in names:
    print(name)
</code></pre>
<p><code>range(i)</code> 生成的序列是从 0 开始小于 i 的整数：</p>
<pre><code class="lang-python">sum = 0
for x in range(101):
    sum = sum + x
print(sum)
</code></pre>
<p>while 循环</p>
<pre><code class="lang-python">sum = 0
n = 99
while n &gt; 0:
    sum = sum + n
    n = n - 2
print(sum)
</code></pre>
<p><code>break</code> 退出循环，<code>continue</code> 跳过当前次循环。</p>
<p>Python 内置了字典：<code>dict</code> 的支持，dict 全称 dictionary，在其他语言中也称为 map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<pre><code class="lang-python">d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}
d[&#39;Michael&#39;]
</code></pre>
<p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入。</p>
<pre><code class="lang-python">d[&#39;Adam&#39;] = 67
</code></pre>
<p>如果key不存在，dict就会报错。要避免 key 不存在的错误，有两种办法，一是通过 in 判断 key 是否存在；二是通过 dict 提供的 get() 方法，如果 key 不存在，可以返回 None，或者自己指定的 value：</p>
<pre><code class="lang-python">d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}
&#39;Thomas&#39; in d
# false
d.get(&#39;Thomas&#39;)
# None
d.get(&#39;Thomas&#39;, -1)
# -1
</code></pre>
<p>和 list 比较，dict 有以下几个特点：</p>
<p>查找和插入的速度极快，不会随着 key 的增加而变慢；
需要占用大量的内存，内存浪费多。
而 list 相反：</p>
<p>查找和插入的时间随着元素的增加而增加；
占用空间小，浪费内存很少。</p>
<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。要创建一个set，需要提供一个list作为输入集合。</p>
<pre><code class="lang-python">s = set([1, 2, 3])
# s 的值为 {1, 2, 3}

# 添加元素到 set 中
s.add(4)

# 删除 set 中的元素
s.remove(4)
</code></pre>
<p>两个set可以做数学意义上的交集、并集等操作。</p>
<pre><code class="lang-python">s1 = set([1, 2, 3])
s2 = set([2, 3, 4])

s1 &amp; s2
# {2, 3}

s1 | s2
# {1, 2, 3, 4}
</code></pre>
<p>再议不可变对象，str 是不变对象，而 list 是可变对象。</p>
<pre><code class="lang-python">a = [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;]
a.sort()
a
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

a = &#39;abc&#39;
b = a.replace(&#39;a&#39;, &#39;A&#39;)
b
# &#39;Abc&#39;
a
# &#39;abc&#39;
</code></pre>
<h2 id="header-1-6">函数</h2>
<p>Python内置了很多有用的函数，我们可以直接调用。</p>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档：<a href="http://docs.python.org/3/library/functions.html#abs" target="_blank">http://docs.python.org/3/library/functions.html#abs</a></p>
<p>定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号 :，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。</p>
<pre><code class="lang-python">def my_abs(x):
    if x &gt;= 0:
        return x
    else:
        return -x
</code></pre>
<p>如果想定义一个什么事也不做的空函数，可以用pass语句：</p>
<pre><code class="lang-python">def nop():
    pass
</code></pre>
<p>数据类型检查可以用内置函数 isinstance() 实现。对参数类型做检查，只允许整数和浮点数类型的参数。</p>
<pre><code class="lang-python">def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError(&#39;bad operand type&#39;)
    if x &gt;= 0:
        return x
    else:
        return -x
</code></pre>
<p>返回多个值。</p>
<pre><code class="lang-python">import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

x, y = move(100, 100, 60, math.pi / 6)
</code></pre>
<p>参数默认值。</p>
<pre><code class="lang-python">def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre>
<p>可变参数。可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个 tuple。</p>
<pre><code class="lang-python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>
<h2 id="header-1-7">高级特性</h2>
<p>切片。</p>
<pre><code class="lang-python">L = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;]
print(L[0:3])
# [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]

print(L[-2:])
# [&#39;Bob&#39;, &#39;Jack&#39;]
</code></pre>
<p>迭代。</p>
<pre><code class="lang-python">for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):
</code></pre>
<p>列表生成式。</p>
<pre><code class="lang-python">a = list(range(1, 11))
print(a)
# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

b = [x * x for x in range(1, 11)]
print(b)
# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

c = [x * x for x in range(1, 11) if x % 2 == 0]
print(c)
# [4, 16, 36, 64, 100]
</code></pre>
<p>generator 生成器。每次调用 next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 的错误。</p>
<pre><code class="lang-python">g = (x * x for x in range(10))
next(g)
# 0
for n in g:
    print(n)
</code></pre>
<h2 id="header-1-8">函数式编程</h2>
<p><code>map()</code> 函数接收两个参数，一个是函数，一个是 <code>Iterable</code>，map 将传入的函数依次作用到序列的每个元素，并把结果作为新的 Iterator 返回。</p>
<pre><code class="lang-python">def f(x):
    return x * x

r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
# [1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>reduce。</p>
<pre><code class="lang-python">from functools import reduce
def fn(x, y):
    return x * 10 + y

a = reduce(fn, [1, 3, 5, 7, 9])
print(a)
# 13579
</code></pre>
<p>filter。</p>
<pre><code class="lang-python">def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
</code></pre>
<p>sorted。</p>
<pre><code class="lang-python"># 按成绩从高到低排序：

L = [(&#39;Bob&#39;, 75), (&#39;Adam&#39;, 92), (&#39;Bart&#39;, 66), (&#39;Lisa&#39;, 88)]

def by_score(t):
    return t[1]

L2 = sorted(L, key=by_score)
print(L2)
# [(&#39;Bart&#39;, 66), (&#39;Bob&#39;, 75), (&#39;Lisa&#39;, 88), (&#39;Adam&#39;, 92)]
</code></pre>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。闭包。</p>
<pre><code class="lang-python">def lazy_sum(*args):
    ax = None
    def sum():
        nonlocal ax
        if ax != None:
            print(&#39;cache&#39;)
            return ax
        else:
            ax = 0
            for n in args:
                ax = ax + n
            print(&#39;count&#39;)
            return ax
    return sum

sum = lazy_sum(1, 2)

print(sum())
# count 3
print(sum())
# cache 3
</code></pre>
<p>匿名函数 lambda。</p>
<pre><code class="lang-python">list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p>
<pre><code class="lang-python">def log(func):
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper

@log
def now():
    print(&#39;2015-3-25&#39;)

now()
</code></pre>
<p>其实就是给函数加一层执行代码。</p>
<p>偏函数: 通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。</p>
<pre><code class="lang-python">import functools
def int2(x, base=2):
    return int(x, base)

a = int2(&#39;10&#39;)
int3 = functools.partial(int, base=8)
b = int3(&#39;10&#39;)
print(a, b)
# 2 8
</code></pre>
<h2 id="header-1-9">模块</h2>
<p>编写一个hello的模块：</p>
<pre><code class="lang-python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#39; a test module &#39;

__author__ = &#39;Xiaoqiang Zhao&#39;

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print(&#39;Hello, world!&#39;)
    elif len(args)==2:
        print(&#39;Hello, %s!&#39; % args[1])
    else:
        print(&#39;Too many arguments!&#39;)

if __name__==&#39;__main__&#39;:
    test()
</code></pre>
<p>遗留问题: 在大项目中，多层目录怎么引入自定义模块？</p>
<p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中</p>
<pre><code class="lang-python">import sys
sys.path
# [&#39;/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/site-packages&#39;]
</code></pre>
<p>如果我们要添加自己的搜索目录：</p>
<pre><code class="lang-python">import sys
sys.path.append(&#39;/Users/michael/my_py_scripts&#39;)
</code></pre>
<p>遗留问题: 不同路径下有同名文件怎么办？</p>
<h2 id="header-1-10">面向对象编程</h2>
<p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>
<pre><code class="lang-python">class Student(object):
    pass

bart = Student()
</code></pre>
<p>特殊的 <code>__init__</code> 方法，负责初始化。</p>
<pre><code class="lang-python">class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

bart = Student(&#39;Bart Simpson&#39;, 59)
</code></pre>
<p>面向对象编程的一个重要特点就是数据封装。</p>
<pre><code class="lang-python">class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print(&#39;%s: %s&#39; % (self.name, self.score))
</code></pre>
<p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p>
<p>变量名类似<strong>xxx</strong>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量。</p>
<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<strong>name是因为Python解释器对外把</strong>name变量改成了_Student<strong>name，所以，仍然可以通过_Student</strong>name来访问__name变量：</p>
<p>但是Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p>
<pre><code class="lang-python">class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print(&#39;%s: %s&#39; % (self.__name, self.__score))

a = Student(&#39;xiaoqiang&#39;, 60)

a.print_score()

# error
# print(a.__score)

# 不规范的使用
print(a._Student__score)
</code></pre>
<p>继承。</p>
<pre><code class="lang-python">class Animal(object):
    def run(self):
        print(&#39;Animal is running...&#39;)

class Dog(Animal):
    pass
</code></pre>
<p>多态。</p>
<pre><code class="lang-python">class Animal(object):
    def run(self):
        print(&#39;Animal is running...&#39;)

class Dog(Animal):
    def run(self):
        print(&#39;Dog is running...&#39;)
</code></pre>
<p>isinstance。</p>
<pre><code class="lang-python">c = Dog()

isinstance(c, Animal)
# True

b = Animal()
isinstance(b, Dog)
# False
</code></pre>
<p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？使用type()</p>
<pre><code class="lang-python">type(123)
# &lt;class &#39;int&#39;&gt;

type(123) == int
# True
</code></pre>
<p>能用type()判断的基本类型也可以用isinstance()判断。并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple。</p>
<pre><code class="lang-python">isinstance([1, 2, 3], (list, tuple))
# True
</code></pre>
<p>如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法。</p>
<pre><code class="lang-python">dir(&#39;ABC&#39;)
# [&#39;__add__&#39;, &#39;__class__&#39;,..., &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;,..., &#39;zfill&#39;]
</code></pre>
<p>类似<strong>xxx</strong>的属性和方法在Python中都是有特殊用途的，比如<strong>len</strong>方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的<strong>len</strong>()方法，所以，下面的代码是等价的：</p>
<pre><code class="lang-python">len(&#39;ABC&#39;)
# 3
&#39;ABC&#39;.__len__()
# 3
</code></pre>
<p>hasattr()</p>
<pre><code class="lang-python">hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？
</code></pre>
<p>实例属性和类属。</p>
<p>实例属性属于各个实例所有，互不干扰；</p>
<p>类属性属于类所有，所有实例共享一个属性；</p>
<p>不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
<pre><code class="lang-python">class Student(object):
    count = 0
</code></pre>
<h2 id="header-1-11">面向对象高级编程</h2>
<p>数据封装、继承和多态只是面向对象程序设计中最基础的3个概念。多重继承、定制类、元类等概念属于面向对象高级编程。</p>
<p>属性限制 <strong>slots</strong>。</p>
<pre><code class="lang-python">class Student(object):
    __slots__ = (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称

s = Student() # 创建新的实例
s.name = &#39;Michael&#39; # 绑定属性&#39;name&#39;
s.age = 25 # 绑定属性&#39;age&#39;
s.score = 99 # 绑定属性&#39;score&#39;
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;
</code></pre>
<p>@property 装饰器负责把一个方法变成属性调用。</p>
<pre><code class="lang-python">class Student(object):
    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value

s.score = 9999
# ValueError: score must between 0 ~ 100!
</code></pre>
<p>多重继承。</p>
<pre><code class="lang-python">class Animal(object):
    pass

# 大类:
# 哺乳动物
class Mammal(Animal):
    pass

# 鸟类
class Bird(Animal):
    pass

# 行为
class Runnable(object):
    def run(self):
        print(&#39;Running...&#39;)

class Flyable(object):
    def fly(self):
        print(&#39;Flying...&#39;)

# 多重继承
class Bat(Mammal, Flyable):
    pass
</code></pre>
<p>定制类。前面的 <strong>init</strong> 、 <strong>slots</strong> 、 <strong>len</strong> 方法能帮我们定制类，还有其他的方法:</p>
<p><strong>str</strong>，定义打印。</p>
<pre><code class="lang-python">class Student(object):
    def __init__(self, name):
    self.name = name
    def __str__(self):
        return &#39;Student object (name: %s)&#39; % self.name

print(Student(&#39;Michael&#39;))
</code></pre>
<p><strong>iter</strong>，如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个<strong>iter</strong>()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong>next</strong>()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<pre><code class="lang-python">class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值

for n in Fib():
    print(n)
</code></pre>
<p>还有 <strong>getitem</strong> 、 <strong>getattr</strong> 和 <strong>call</strong>，先跳过，用到的时候再看。高级技巧其实约等于低频技巧。</p>
<p>枚举类。</p>
<pre><code class="lang-python">from enum import Enum
Month = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))

for name, member in Month.__members__.items():
    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)

# Jan =&gt; Month.Jan , 1
# ...
</code></pre>
<p>value属性则是自动赋给成员的int常量，默认从1开始计数。如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：</p>
<pre><code class="lang-python">from enum import Enum, unique

# @unique 装饰器可以帮助我们检查保证没有重复值
@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
</code></pre>
<p>访问这些枚举类型可以有若干种方法：</p>
<pre><code class="lang-python">day1 = Weekday.Mon
print(day1)
# Weekday.Mon

print(Weekday[&#39;Tue&#39;])
# Weekday.Tue

print(Weekday.Tue.value)
# 2

print(day1 == Weekday.Mon)
# True

print(day1 == Weekday.Tue)
# False

print(Weekday(1))
# Weekday.Mon

print(day1 == Weekday(1))
# True

Weekday(7)
# Traceback (most recent call last):
#  ...
# ValueError: 7 is not a valid Weekday

for name, member in Weekday.__members__.items():
    print(name, &#39;=&gt;&#39;, member, member.value)

# Sun =&gt; Weekday.Sun 0
# ...
</code></pre>
<p>元类。据说用不到...</p>
<h2 id="header-1-12">错误、调试和测试</h2>
<p>catch 换成了 except。</p>
<pre><code class="lang-python">try:
    print(&#39;try...&#39;)
    r = 10 / 0
    print(&#39;result:&#39;, r)
except ZeroDivisionError as e:
    print(&#39;except:&#39;, e)
finally:
    print(&#39;finally...&#39;)
print(&#39;END&#39;)
</code></pre>
<p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。最佳实践是把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p>
<pre><code class="lang-python">import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except Exception as e:
        logging.exception(e)

main()
print(&#39;END&#39;)
</code></pre>
<p>错误是class，捕获一个错误就是捕获到该class的一个实例。错误并不是凭空产生的，而是有意创建并抛出的。如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例。</p>
<pre><code class="lang-python">class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n==0:
        raise FooError(&#39;invalid value: %s&#39; % s)
    return 10 / n

foo(&#39;0&#39;)
</code></pre>
<p>VS Code IDE 中断点调试很方便，不展开了。</p>
<p>为了编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下。</p>
<pre><code class="lang-python">import unittest

from mydict import Dict

class TestDict(unittest.TestCase):

    def test_init(self):
        d = Dict(a=1, b=&#39;test&#39;)
        self.assertEqual(d.a, 1)
        self.assertEqual(d.b, &#39;test&#39;)
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d[&#39;key&#39;] = &#39;value&#39;
        self.assertEqual(d.key, &#39;value&#39;)

    def test_attr(self):
        d = Dict()
        d.key = &#39;value&#39;
        self.assertTrue(&#39;key&#39; in d)
        self.assertEqual(d[&#39;key&#39;], &#39;value&#39;)

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d[&#39;empty&#39;]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty
</code></pre>
<h2 id="header-1-13">IO编程</h2>
<p>读文件。</p>
<pre><code class="lang-python">try:
    f = open(&#39;/path/to/file&#39;, &#39;r&#39;)
    print(f.read())
finally:
    if f:
        f.close()
</code></pre>
<p>简化写法。</p>
<pre><code class="lang-python">with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f:
    print(f.read())
</code></pre>
<p>按行读取。</p>
<pre><code class="lang-python">for line in f.readlines():
    print(line.strip()) # 把末尾的&#39;\n&#39;删掉
</code></pre>
<p>读取二进制文件。</p>
<pre><code class="lang-python">f = open(&#39;./test.jpg&#39;, &#39;rb&#39;)
</code></pre>
<p>要读取非UTF-8编码的文本文件，需要给open()函数传入 encoding 参数。</p>
<pre><code class="lang-python">f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;)
</code></pre>
<p>操作文件和目录。</p>
<pre><code class="lang-python">import os
print(os.name)
</code></pre>
<p>变量从内存中变成可存储或传输的过程称之为序列化，反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化。</p>
<pre><code class="lang-python">import pickle
# 序列化
d = dict(name=&#39;Bob&#39;, age=20, score=88)
pickle.dumps(d)
# b&#39;\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&#39;

# 反序列化
f = open(&#39;dump.txt&#39;, &#39;wb&#39;)
pickle.dump(d, f)
f.close()
</code></pre>
<pre><code class="lang-python">

</code></pre>
<pre><code class="lang-python">

</code></pre>
<h2 id="header-1-14">Django</h2>
<p>Django 已经成为 web 开发者的首选框架</p>
<h2 id="header-1-15">参考</h2>
<p>官网: <a href="https://www.python.org/" target="_blank">https://www.python.org/</a>
Python 新手入门引导: <a href="https://zhuanlan.zhihu.com/p/25824007" target="_blank">https://zhuanlan.zhihu.com/p/25824007</a>
廖雪峰 Python 教程: <a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank">https://www.liaoxuefeng.com/wiki/1016959663602400</a></p>

</div>
</body>
</html>