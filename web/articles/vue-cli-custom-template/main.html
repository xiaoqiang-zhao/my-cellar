<!DOCTYPE html>
<html>
<head lang="zh-cn">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>vue-cli 定义模板 - 龙则的个人站点</title>
    <script>
        // 用户通过搜索引擎到文章详情页时，跳到首页并进行哈希路由
        var href = window.location.href.replace(/[^:|\/]\//,function (matchStr){
            return matchStr + 'index.html#!';
        });
        window.location.href = href.replace('/main.html', '');
    </script>
</head>
<body>
<header>
    <h1> 龙则的个人站点 </h1>
    <h2> 精进自己，服务他人 </h2>
</header>
<div>
    <h1 id="header-1">vue-cli 定义模板</h1>
<blockquote>
<p>由于 vue-cli 官方提供的模板不能满足前后端分离的工作模式(工具链层面的)，需要定制自己的模板，这篇文章主要讲怎样定制一个模板，并介绍一下我定制的模板特性，此模板作为我将来的开源项目脚手架。</p>
</blockquote>
<h2 id="header-1-1">站在巨人的肩上</h2>
<p>我们的总体思路是最大限度的利用官方已有模板，进行改造和增强。我在 github 上建了一个 organization: <a href="https://github.com/vuejs-custom-templates-aggregate" target="_blank">vuejs-custom-templates-aggregate</a> ---- vue 自定义模板集合。然后将 <a href="https://github.com/vuejs-templates/webpack" target="_blank">https://github.com/vuejs-templates/webpack</a> 项目 fork 进 vuejs-custom-templates-aggregate(vue 自定义模板集合)，我给他取了个名字叫 spa-simple。之所以没叫 webpack-spa，是应为 browserify 用的人越来越少了，大家提到包加载器基本默认就是 webpack，另外我想从应用场景来区分模板，并大胆的幻想将来出现的其他模板是：</p>
<ul>
<li>spa-simple 纯前端单页应用；</li>
<li>spa-full-stack 全栈单页应用，后端提供业务模板和数据库；</li>
<li>spa-simple-ts 单页应用 typescript 版；</li>
<li>spa-full-stack-ts 全栈单页应用 typescript 版；</li>
<li>mpa 纯前端多页应用。</li>
</ul>
<p>然后我们将 spa-simple 用 git clone 到本地，进行下一步。</p>
<h2 id="header-1-2">改造前的观察</h2>
<h3 id="header-1-2-1">概述</h3>
<p>先看看有什么功能，看着有用的保留，没用的去除：</p>
<ul>
<li>Project name 保持不变；</li>
<li>Project description 保持不变；</li>
<li>Author 保持不变；</li>
<li>Vue build 去掉，直接采用 Runtime-only 方案；</li>
<li>Install vue-router 去掉，直接选中；</li>
<li>ESLint 改为默认选中；</li>
<li>Pick an ESLint preset 选一种编码格式，便于集成更多的代码进来；</li>
<li>Setup unit tests with Karma + Mocha 保留；</li>
<li>Setup e2e tests with Nightwatch 保留；</li>
</ul>
<p>其中有一些不太好理解，下面讲一下：</p>
<h3 id="header-1-2-2">Vue build</h3>
<p>讲一下 Runtime + Compiler 和 Runtime-only 的区别，首先我们从知其然的角度来说：</p>
<ul>
<li>Runtime + Compiler: 支持 template，如果用了 SSR，前后端要同构，那么不能用；</li>
<li>Runtime-only: 体积小 6KB，不支持 template，模板只能写在 .vue 文件中。</li>
</ul>
<p>所谓的“支持 template”，就是下面这种形式：</p>
<pre><code>export default {
    name: &#39;hello&#39;,
    template: &#39;&lt;h1&gt;{{msg}}&lt;/h1&gt;&#39;,
    data() {
        return {
            msg: &#39;Welcome to Your Vue.js App&#39;
        }
    }
}
</code></pre><p>两种模式对下面写法都是支持的：</p>
<pre><code>&lt;template src=&quot;./index.tpl&quot;&gt;&lt;/template&gt;
&lt;!-- 或者直接在 template 中写模板--&gt;
&lt;script&gt;
    export default {
    name: &#39;hello&#39;,
        data() {
            return {
                msg: &#39;Welcome to Your Vue.js App&#39;
            }
        }
    }
&lt;/script&gt;
</code></pre><p>然后我们再探一下因 -- 知其所以然，模板转化成 html 并绑定事件有一个必不可少的步骤，那就是将模板转换成函数，这一步称为编译，数据和 html 标签的融合并输出 Dom 结构就是在编译后产生的函数中进行的，如果在打包的过程中完成编译，并将编译产生的函数打入代码中，那么发布出来的代码就没有必要包含这部分功能了，这部分功能压缩后所占的体积就是上面提到的 6KB。</p>
<p>还有另外一个问题，这个开关是在哪里控制的？
在 build/webpack.base.conf.js 中：</p>
<pre><code>resolve: {
    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],
    alias: {
        &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;,
        &#39;@&#39;: resolve(&#39;src&#39;)
    }
}
</code></pre><p>默认是不提供 Compiler 功能的，如果我们需要，把 vue 的引用指向 vue 代码包中的另一个文件 -- vue.esm.js，这个文件包含了 Compiler 功能。可以看到添加时很简单的，所以我们这里去掉 Compiler 功能的支持，万一有需要可以手动加回来。</p>
<h3 id="header-1-2-3">ESLint</h3>
<p>本来不打算讲这一块的，但是发现有几处需要注意的地方，花了点时间才搞明白。eslint 是用 node 写的，所以需要有 node 环境，并全局安装 eslint，IDE 才能玩的转：</p>
<pre><code>sudo npm install -g eslint
// 为了能检测 .vue 文件，还需要装 eslint 插件
sudo npm install -g eslint-plugin-html
</code></pre><p>vs code 需要加配置：</p>
<pre><code>&quot;eslint.options&quot;: {
    &quot;configFile&quot;: &quot;./.eslintrc.js&quot;,
    &quot;plugins&quot;: [&quot;html&quot;]
},
&quot;eslint.validate&quot;: [
    &quot;javascript&quot;,
    &quot;html&quot;,
    &quot;vue&quot;
]
</code></pre><p>现在的规范有 3 种类型：</p>
<ul>
<li>standard 互联网通用，约束较轻；</li>
<li>airbnb 约束较具体；</li>
<li>none 没有约束。</li>
</ul>
<p>最后注意一点，如果把编码规范的 level 设为 2(也就是 error)，那么在编码格式有问题的时候运行会直接报错。</p>
<ul>
<li>&quot;off&quot; 或 0 - 关闭规则；</li>
<li>&quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)；</li>
<li>&quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)。</li>
</ul>
<p>另外可以看到，编码规范的选择让模板显得异常臃肿：</p>
<pre><code>export default {
  name: &#39;app&#39;{{#router}}{{#if_eq lintConfig &quot;airbnb&quot;}},{{/if_eq}}{{else}},
  components: {
    Hello{{#if_eq lint Config &quot;airbnb&quot;}},{{/if_eq}}
  }{{#if_eq lintConfig &quot;airbnb&quot;}},{{/if_eq}}{{/router}}
}{{#if_eq lintConfig &quot;airbnb&quot;}};{{/if_eq}}
</code></pre><p>为了一个逗号和行尾的封号写了很多的判断，对于一个团队来说定制一种编码规范改一下模板的成本会更小。如果想要初始化一些公用功能进去，这样判断需要大面积存在，特别不利于模板的二次定制，所以我们会选择一种在开源届使用广泛的规范来作为唯一的规范。编码规范的详细内容查看我的另一篇文章<a href="/#!/articles/fe-code-style" target="_blank">前端编码规范</a>。</p>
<h2 id="header-1-3">开始改造现有功能</h2>
<p>写 vue 模板并没有什么特别好的方法，因为模板改完之后需要编译后才能运行，所以我们先用现有模板生成一份比较全的，然后把相关依赖装好，提交到 github 上，然后改这个模板生成后的项目，改一部分验证一部分，验证没问题之后把修改点同步回模板中，这是我能想到的最简单快捷的方式。</p>
<h3 id="header-1-3-1">Vue build</h3>
<p>关于这个选项的描述上面已经讲过了，策略是去掉询问，直接用 <code>Runtime-only</code> 方案。首先删除配置：</p>
<pre><code>// meta.js
&quot;build&quot;: {
  &quot;type&quot;: &quot;list&quot;,
  &quot;message&quot;: &quot;Vue build&quot;,
  &quot;choices&quot;: [
    {
      &quot;name&quot;: &quot;Runtime + Compiler: recommended for most users&quot;,
      &quot;value&quot;: &quot;standalone&quot;,
      &quot;short&quot;: &quot;standalone&quot;
    },
    {
      &quot;name&quot;: &quot;Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specific HTML) are ONLY allowed in .vue files - render functions are required elsewhere&quot;,
      &quot;value&quot;: &quot;runtime&quot;,
      &quot;short&quot;: &quot;runtime&quot;
    }
  ]
},
</code></pre><p>然后修改 template/src/main.js</p>
<pre><code>// 去掉这部分的判断和里面的内容
{{#if_eq build &quot;standalone&quot;}}
// 去掉 template 的定义和判断，直接用 render 函数，
// 简单的说就是改成下面这样
new Vue({
    el: &#39;#app&#39;,
    router,
    render: h =&gt; h(App),
    components: { App }
});
</code></pre><p>最后去掉 template/build/webpack.base.conf.js 中的下面这部分判断：</p>
<pre><code>{{#if_eq build &quot;standalone&quot;}}
&#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;,
{{/if_eq}}
</code></pre><h3 id="header-1-3-2">router</h3>
<p>这个是一个项目必须的功能，如果只想写个 Demo 那直接用官方的模板好了。我们首先需要改配置：</p>
<p>首先删除下面的配置，使不再询问是否安装router：</p>
<pre><code>// meta.js，
&quot;router&quot;: {
  &quot;type&quot;: &quot;confirm&quot;,
  &quot;message&quot;: &quot;Install vue-router?&quot;
},
</code></pre><p>然后去掉过滤的设置，使其恒定不过滤：</p>
<pre><code>&quot;filters&quot;: {
  &quot;.eslintrc.js&quot;: &quot;lint&quot;,
  &quot;.eslintignore&quot;: &quot;lint&quot;,
  &quot;config/test.env.js&quot;: &quot;unit || e2e&quot;,
  &quot;test/unit/**/*&quot;: &quot;unit&quot;,
  &quot;build/webpack.test.conf.js&quot;: &quot;unit&quot;,
  &quot;test/e2e/**/*&quot;: &quot;e2e&quot;,
  // 删掉下面一行
  &quot;src/router/**/*&quot;: &quot;router&quot;
},
</code></pre><p>还有 template/src/main.js 需要改，一大堆判断真是复杂，直接去掉，最后像下面这样：</p>
<pre><code>import Vue from &#39;vue&#39;;
import App from &#39;./App&#39;;
import router from &#39;./router&#39;;

Vue.config.productionTip = false;
new Vue({
  el: &#39;#app&#39;,
  router,
  render: h =&gt; h(App),
  components: { App }
});
</code></pre><p>最后把 template/package.json 里面对 <code>vue-router</code> 包的判断去掉，这个功能就改造完成了，我们试着跑一下:</p>
<pre><code>//            本地模板路径        测试项目名
vue init ~/code-github/spa-simple spa-simple-router
cd spa-simple-router
yarn
npm run dev
</code></pre><p>耶，完美✌️.</p>
<p>注：</p>
<ul>
<li>1、不安装测试会快很多；</li>
<li>2、我们打算干掉编码规范，所以选择 none</li>
</ul>
<h2 id="header-1-4">添加 Mock 功能</h2>
<h3 id="header-1-4-1">原有功能分析</h3>
<p>先看看原来的和 server 有关的功能，首先从 package.json 中了解到启动开发环境是从 dev-server.js 文件开始的。首先通过 express 启动 Web 服务：</p>
<pre><code>var app = express()
// ...
var server = app.listen(port)
</code></pre><p>然后通过中间件 webpack-dev-middleware 路由静态文件：</p>
<pre><code>var devMiddleware = require(&#39;webpack-dev-middleware&#39;)(compiler, {
    publicPath: webpackConfig.output.publicPath,
    quiet: true
})
</code></pre><p>再然后通过中间件 webpack-hot-middleware 提供热加载：</p>
<pre><code>var hotMiddleware = require(&#39;webpack-hot-middleware&#39;)(compiler, {
    log: false,
    heartbeat: 2000
})
</code></pre><p>热加载需要 webpack 插件配合才能实现：</p>
<pre><code>// 当 html 模板改变时，触发页面重新加载
compiler.plugin(&#39;compilation&#39;, function (compilation) {
    compilation.plugin(&#39;html-webpack-plugin-after-emit&#39;, function (data, cb) {
        hotMiddleware.publish({ action: &#39;reload&#39; })
        cb()
    })
})
</code></pre><p>再然后是代理，用的中间件 http-proxy-middleware，可以设置多个代理：</p>
<pre><code>Object.keys(proxyTable).forEach(function (context) {
    var options = proxyTable[context]
    if (typeof options === &#39;string&#39;) {
        options = { target: options }
    }
    app.use(proxyMiddleware(options.filter || context, options))
})
</code></pre><p>最后用 connect-history-api-fallback 中间件支持 HTML5 History，原理就是将所有的 text/html 请求都打到 /index.html 上，当然这个是可以设置的，像下面这样：</p>
<pre><code>var history = require(&#39;connect-history-api-fallback&#39;);
app.use(history({
    index: &#39;/default.html&#39;
}));
</code></pre><p>其实看到这里我们就明白了，官方想让我们通过代理直接调用 server，但是我们开发的流程一般是定完接口前后端个开发各的，然后联调。对于全栈来说启两个项目很显然来回切换很麻烦，但是官方并没有提供全栈的模板，我们后面会完善。</p>
<h3 id="header-1-4-2">功能改造和增强</h3>
<p>找了很久没找到一个 start 数较高的自动路由中间件(根据访问路径直接读取相同路径模块并返回结果)，可能因为这种包对于后台开发来说太鸡肋，像下面这种路由需要将 id 写死：</p>
<pre><code>articles/:id
</code></pre><p>但是在脚手架 Mock 功能上这是很通用的需求，其中最核心的功能需求是不需要每新加一个接口都要改配置文件，直接添加文件就好了，这也是一种思路的体现 -- 流程优于配置。所以决定先造个轮子: 
<a href="https://github.com/longze/express-auto-path-router" target="_blank">express-auto-path-router</a>。
怎么开发中间件这里就不展开了，解决的主要问题就是省略路由配置文件，路由和功能的对应采用一种逻辑关系，规则如下：</p>
<pre><code>GET /a -&gt; /GET/a/index.js
POST /a -&gt; /POST/a/index.js
</code></pre><p>这对于我们写 Mock 数据是很便捷的方式，我们先把 axios 加进来：</p>
<pre><code>// mian.js
import axios from &#39;axios&#39;;
// 将axios挂载到prototype上，在组件中可以直接使用this.$http访问
Vue.prototype.$http = axios;
</code></pre><p>然后加 Mock 功能，之前只有代理模式，现在我们要加一种提供数据的模式 Mock，考虑到后面我们还要加全栈模式，这里把配置顺便升一下级：</p>
<pre><code>// config/index.js
dataType: &#39;mock&#39;,  // proxy:代理; mock:模拟; full-stack:全栈(默认此项)
proxyTable: {
  &#39;/&#39;: {
    target: &#39;http://172.0.0.1:8800/&#39;
  }
},
mockTable: {
  // 相对于整个项目的路径
  rootPath: &#39;./mock/&#39;
}
</code></pre><p>然后改造路由，添加 mock 路由和 proxy 路由以及全栈路由的区分逻辑，关键代码如下：</p>
<pre><code>// build/dev-server.js
var expressAutoPathRouter = require(&#39;express-auto-path-router&#39;)
// Define HTTP proxies to your custom API backend
// https://github.com/chimurai/http-proxy-middleware
if (config.dev.dataType === &#39;proxy&#39;) {
Object.keys(config.dev.proxyTable).forEach(function (context) {
    var options = proxyTable[context]
    if (typeof options === &#39;string&#39;) {
        options = { target: options }
    }
    app.use(proxyMiddleware(options.filter || context, options))
  })
}
// https://github.com/longze/express-auto-path-router
else if (config.dev.dataType === &#39;mock&#39;) {
  app.use(expressAutoPathRouter(config.dev.mockTable.rootPath))
}
</code></pre><p>最后添加 mock 数据的文件夹和客户端的调用逻辑：</p>
<pre><code>// mock 数据的写法
// mock/GET/a/index.js
let mock = require(&#39;mockjs&#39;);
module.exports = function (param) {
    return {
        status: 0,
        statusInfo: &#39;&#39;,
        data: mock.Random.cparagraph()
    };
};
// 前端调用
// src/components/Hello.vue
data () {
    this.$http.get(&#39;/a&#39;).then(res =&gt; {
        console.log(&#39;mock 数据支持成功&#39;, res)
    })
    return {
        msg: &#39;Welcome to Your Vue.js App&#39;
    }
}
</code></pre><p>到此为止 mock 数据功能就基本添加完了，把添加的代码同步到模板中就不展开了。</p>
<p>开发完成后就可以联调了，将 dataType 的配置改为 proxy，然后启动项目，所有的 Ajax 请求将会被代理到 target 配置的服务器上。</p>
<pre><code>// config/index.js
dataType: &#39;proxy&#39;,
proxyTable: {
  &#39;/&#39;: {
    target: &#39;http://172.0.0.1:8800/&#39;
  }
},
</code></pre><h2 id="header-1-5">改造代码格式验证</h2>
<p>改造此处 ---- </p>
<p>我们打算去掉 ESlint 的询问，并且配置自己的验证规则，最后给出 IDE 的支持。</p>
<h3 id="header-1-5-1">去除 ESlint 询问配置</h3>
<p>去除下面三项配置，这样在安装的时候就不会询问了：</p>
<pre><code>// meta.js
&quot;lint&quot;: {
  &quot;type&quot;: &quot;confirm&quot;,
  &quot;message&quot;: &quot;Use ESLint to lint your code?&quot;
},
&quot;lintConfig&quot;: {
   // 此处省略若干行... 
}
// 去除 eslint 相关的过滤
filters
&quot;.eslintrc.js&quot;: &quot;lint&quot;,
&quot;.eslintignore&quot;: &quot;lint&quot;,
</code></pre><p>然后修改依赖包的判断逻辑：</p>
<pre><code>// template/package.json
// 去掉 {{#lint}} 成对的判断，我们恒定需要
{{#lint}}
// 去掉下面两项的判断和其中的内容
{{#if_eq lintConfig &quot;standard&quot;}}
{{#if_eq lintConfig &quot;airbnb&quot;}}
</code></pre><p>eslint 的配置文件也需要更改：</p>
<pre><code>// template/.eslintrc.js
// 去掉 {{#if_eq lintConfig &quot;standard&quot;}} 之间的内容，上下共 3 处
// 去掉 {{#if_eq lintConfig &quot;airbnb&quot;}} 之间的内容，上下共 3 处
</code></pre><p>webpack 中的配置改一下：</p>
<pre><code>// template/build/webpack.base.conf.js
// 去掉 {{#lint}} 成对的判断，我们恒定需要
</code></pre><p>最后把项目代码改一下，<code>template/src</code> 下的全部文件过一下，地方太多但是改起来很容易，我就不一个个的粘上来了。</p>
<h3 id="header-1-5-2">改 ESLint</h3>
<p>在 rules 中添加两条演示规则，最通用的两条：缩进两个空格，语句不能省略封号。</p>
<pre><code>// template/.eslintrc.js
&#39;indent&#39;: [level, 2],
&#39;semi&#39;: [2, &#39;always&#39;],
</code></pre><p>更多配置在这里：<a href="https://eslint.org/docs/rules/" target="_blank">https://eslint.org/docs/rules/</a></p>
<h3 id="header-1-5-3">vscode 插件</h3>
<p>如果你和我一样用的是 vscode，先全局装一下 eslint 包和插件：</p>
<pre><code>sudo npm install -g eslint
// 为了能检测 .vue 文件，还需要装 eslint 插件
sudo npm install -g eslint-plugin-html
</code></pre><p>然后在工作区设计里加上配置：</p>
<pre><code>&quot;eslint.options&quot;: {
    &quot;configFile&quot;: &quot;./.eslintrc.js&quot;,
    &quot;plugins&quot;: [&quot;html&quot;]
},
&quot;eslint.validate&quot;: [
    &quot;javascript&quot;,
    &quot;html&quot;,
    &quot;vue&quot;
]
</code></pre><p>最后把生成的文件 <code>settings.js</code> 连同文件夹 <code>.vscode</code> 拷贝进 <code>template</code>。</p>
<p>其他的支持请自行 google。</p>
<h3 id="header-1-5-4">小遗憾</h3>
<p>本来样式也应该这样搞一下的，但是没找到比较好的工具和插件。最好用的也要算是 EFE 的 <a href="https://github.com/ecomfe/node-csshint" target="_blank">csshint</a>了，但是定制能力不足，缺 IDE 插件支持。less、sass、stylus 可能需要不同的规则支持，不知道有没有比较好的规范和工具，这一块的配置可以加上。</p>
<p>另外还有一种走全家桶路线思路，集成化格式验证工具中比较好用的是 FECS：<a href="https://github.com/ecomfe/fecs/wiki/CSSHint" target="_blank">https://github.com/ecomfe/fecs/wiki/CSSHint</a></p>
<h2 id="header-1-6">style 强化</h2>
<h3 id="header-1-6-1">预处理器</h3>
<p>CSS 在项目中必不可少，一般我们会引入预处理器来增强原生 CSS 的一些不足，但是官方模板并没有完全支持，每种预处理器都需要单独安装，如你想使用 less，那么需要手动安装<code>less</code> 和 <code>less-oader</code>两个包：</p>
<pre><code>npm install less --save-dev
npm install less-loader --save-dev
</code></pre><p>安装后把生成的配置添加到 template/package.json 中：</p>
<pre><code>&quot;less&quot;: &quot;^3.0.0-alpha.3&quot;,
&quot;less-loader&quot;: &quot;^4.0.5&quot;,
</code></pre><p>我们的项目用的是 Less，这里只把 Less 的依赖添加了进去，如果需要可以自行添加其他预处理器。</p>
<p>另外再补充一点，webpack 对各种预处理器的配置在 template/build/utils.js 中生成，规则就是：预处理器名-loader：</p>
<pre><code>loaders.push({
    loader: loader + &#39;-loader&#39;,
    options: Object.assign({}, loaderOptions, {
        sourceMap: options.sourceMap
    })
})
</code></pre><p>Less 规范：<a href="https://github.com/ecomfe/spec/blob/master/less-code-style.md" target="_blank">https://github.com/ecomfe/spec/blob/master/less-code-style.md</a></p>
<h3 id="header-1-6-2">iconfont</h3>
<p>todo...</p>
<p>代码格式...</p>
<p>项目目录结构...</p>
<h2 id="header-1-7">支持未压缩的打包</h2>
<p>在测试环境需要一个不压缩的包，发现脚手架没有提供，这里实现一下：</p>
<pre><code>// build/build.js
if (process.argv.indexOf(&#39;--qa&#39;)) {
  webpackConfig.plugins.splice(1, 1)
}
// package.json
&quot;scripts&quot;: {
  // 添加此行配置
  &quot;qa&quot;: &quot;node build/build.js --qa&quot;
}
</code></pre><p>然后命令行 <code>npm run qa</code> 就可以打出测试包了，这样可以很方便的在测试环境定位问题。</p>
<h2 id="header-1-8">webpack</h2>
<p>webpack 是一个比较重要的技能，这里简单讲一下，</p>
<h2 id="header-1-9">问题</h2>
<p>不支持 less？没包</p>
<p>&quot;less&quot;: &quot;^2.7.1&quot;,
&quot;less-loader&quot;: &quot;^2.2.3&quot;,</p>
<p>less 的 alias 设置研究。</p>
<p>不支持未压缩的打包</p>
<h2 id="header-1-10">参考</h2>
<p><a href="http://gcdn.gcpowertools.com.cn/showtopic-36912-1-3.html?utm_source=segmentfault&amp;utm_medium=referral&amp;utm_campaign=20170417&amp;utm_content=36912" target="_blank">http://gcdn.gcpowertools.com.cn/showtopic-36912-1-3.html?utm_source=segmentfault&amp;utm_medium=referral&amp;utm_campaign=20170417&amp;utm_content=36912</a></p>

</div>
</body>
</html>